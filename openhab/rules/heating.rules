val Functions$Function0<String> getEmailText = [
  val String WAN_ADDRESS_FRITZ = "xdbu92gos1irkzbd.myfritz.net"
  wanAddress.postUpdate(WAN_ADDRESS_FRITZ)

  val String emailText='
    IP = http://'+wanAddress.state.toString+':8080/basicui/app?sitemap=garden_control\n
    Grafana = http://'+wanAddress.state.toString+':8030'/*GRAFANA_PORT*/+'/d/5KXuWvZRk/overview?tab=advanced&orgId=1&from=now-6h&to=now&refresh=1h\n
    Smart Home = http://'+wanAddress.state.toString+':8080/basicui/app?sitemap=smarthome\n'	
  //logDebug("getEmailText","EmailText  = {}",emailText)

  return emailText
]

// rule "floor heating pump night control"
// when 
//   Time cron "0 0/10 22-23,0-2 * 10-12,1-5 * " or
//   Time cron "0 0    0         * 6-8 *" // summer always OFF
//   then
//     val PumpOnOff = PumpeFussbodenheizung.state
//     val onOff = OFF
//     // the socket might be unavailable then it is OFF that's what we want
//     // if it is ON and it should be OFF we turn it OFF
//     // we just don't care and turn it OFF even if we do not know its state    
//     logDebug("floor heating pump night control", "night time, hour = {}, pump {}",now.hour,PumpOnOff)
//     PumpeFussbodenheizung.sendCommand(onOff)
//     logDebug("floor heating pump night control", "pump NOW is {}",onOff)
// end

// only the members of group "Alerting" will cause a mail to be sent when changed 
rule Bureau_IR_group_Alerting
when Member of Alerting changed
then
  	var actions = getActions("mail","mail:smtp:mysmtp")
  	actions.sendMail("uwe@janssen-muenchen.de","Alert rule: "+triggeringItem.name + " = "+triggeringItem.state, getEmailText.apply())
end
// Always log a change
rule Bureau_IR_group
when Member of Bureau_IR_group changed
then 
  logInfo("Bureau_IR_group", triggeringItem.name + " = "+triggeringItem.state)
end 

rule "Heating OFF"
// nightly heating stop
  when
    //Time cron "0 0/5 * * * ? " // near future test 
    Time cron "0 00 0-6 * * ? " or
    Time cron "0 00 21-23 * * ? "
  then
    Set_Bureau_IR_temp.sendCommand("18")
    DECT_301_radiator_mode.sendCommand("ECO")
end

rule "Heating Power" 
  when Member of HeatingDevices changed
  then
    var String varName = ""
    var Number varValue = 0
    // HeatingDevices.members.forEach[ item | 	
		// 	if (item.name.state == "OFF") {
		// 		do something with item.name
		// 	}
		// ]
    // create triggering object first
//    HeatingDevices.members.filter[ a | a.name == "Bureau_IR_work_state"] as SwitchItem
      varName = triggeringItem.name +"_Power"

      // TODO: use transformation ON,800 or 60 && OFF,0
    logInfo("Heating Power", triggeringItem.name + " = "+triggeringItem.state+" new varName = "+varName)
    val PowerItem = gHeatingPower.members.findFirst [ it | name == varName ] 
    logInfo("Heating Power", "PowerItem = "+ PowerItem)
      // TODO: use transformation ON,800 or 60 && OFF,0 
      // or use a hashMap for the different devices (bad since code had to be edited)
    if ( triggeringItem.state == ON || triggeringItem.state == "heating") {
      if (varName == "Bureau_IR_work_state_Power"){
        varValue = 800
      } else {
        varValue = 60
      }
    }
      else {
        varValue = 0
    }
    logInfo("Heating Power","setting "+ PowerItem + " TO "+varValue)
    PowerItem.postUpdate(varValue)
  end

rule "SmartHeating"
// control heating in bureau depending on power 
// depending on how much is fed into the grid and SOC (State Of Charge, i.e. battery power) 
  when Member of gSmartPower changed
  then 
    val boolean heatingPeriod = ( now.getHour > 8 && now.getHour < 23)
    // use the set value if not LOW_TEMP
    val Number HIGH_TEMP = 26 
    val Number LOW_TEMP = 18
    val Number COMFORT_TEMP = if ((Set_Bureau_IR_temp.state as Number) == LOW_TEMP ) HIGH_TEMP else  Set_Bureau_IR_temp.state
    logDebug("SmartHeating","Using {} as COMFORT_TEMP",COMFORT_TEMP)
//    val Number HEATING_POWER = 0.800 // kW
    val Number solarPower =  Solar_power_calculated.state as Number // kW
    val Number soc = SOC.state // battery level
    val Number MIN_SOC = 75 // percent
    val boolean enoughBattery = (soc > MIN_SOC)
    //val Number gridpower = (GridPower.state as Number)*1000
    val Number MIN_GRID_FEED = 0.2 // kW
    val Number MAX_SOLAR_POWER = 10 // kW , maximum 8kW peak from the roof and maximum 1kW from the mini PV
    var Number gridPowerAverage = 0
    val Number solarPowerMini = (Solar600_P_AC.state as Number)/1000 //  kW
    val Number gridPower = GridPower.state as Number
    val Number actualTemperature = (Bureau_IR_temp.state as Number).intValue
// plausi check gridPower value
    if (gridPower > MAX_SOLAR_POWER) {
      logError("SmartHeating","max grid power exceeded: gridPower [{}] kW > MAX_SOLAR_POWER [{}] kW. DO NOTHING, just leave.",gridPower, MAX_SOLAR_POWER)
      return
    } else {
      // value in Range, so persist gridPower and its average in influx DB for grafana usage
      GridPower.persist
      gridPowerAverage = GridPower.averageSince(now.minusMinutes(10))
      // store item 
      GridAverageProxy.postUpdate(gridPowerAverage)
      // store in DB
      GridAverageProxy.persist
      logDebug("SmartHeating","valid grid power: {} < {} [kW]. Store in DB ",gridPower, MAX_SOLAR_POWER)
    }

    val boolean enoughPower = 
      enoughBattery ||
      gridPowerAverage > MIN_GRID_FEED /* at least 100W grid feed in the last 10 minutes should be achieved */

    // PLAUSI CHECK: average against 
    // if (grid power average > 0 ) // einspeisung
    // && if solarPowerDach + SolarPowerMini > gridPower -> ERROR

    val Number powerSum = solarPower+solarPowerMini // Watt


    if (powerSum > 0.5 && powerSum < gridPowerAverage) { // ignore small diffs
      logDebug("SmartHeating","SUM of Solar Power = {} kW < gridPowerAverage = {} kW. DO NOTHING, just leave.",powerSum, gridPowerAverage)
      return
    }
    GridAverageProxy.postUpdate(gridPowerAverage)

    //val boolean socDecreasing =  (soc < socLast)
    //val boolean shallHeat = /*!socDecreasing && */enoughPower
    val String POWER_STR = (if (enoughPower) "Enough Power. will HEAT " else "NOT ENOUGH POWER: Battery Level "+soc+"%, turn DOWN ")
    var Number temperature = LOW_TEMP


    // conditions to do sth.
    // 
    // 1. (Missing) there muste be a change of conditions versus last rule invocation 
    // 2. inside heating period
    // 3. IR heater is not OFF
    val boolean doSomething = enoughPower && heatingPeriod && Bureau_IR_on_off.state != OFF 
    val boolean actualWorkStateCold = Bureau_IR_work_state.state == "standby"
    var boolean currentWorkStateCold =  false
    if (doSomething) {
      // turn higher if ON
      temperature = COMFORT_TEMP
      logDebug("SmartHeating",POWER_STR+", gridAverage = {},  turn IR temperature to {}", gridPowerAverage,temperature)
    } else {
      currentWorkStateCold = true
      logDebug("SmartHeating","No change -> do nothing, heatingPeriod = {}, IR heating ON/OFF = {}", heatingPeriod, Bureau_IR_on_off.state)
    }
    // avoid steadily setting temperature if there is nothing to do (avoid aggravating beep of the IR heating when setting temperature)
    val Number tempDiff = (temperature - actualTemperature)
    val Number absoluteTempDiff = (tempDiff*tempDiff)/tempDiff // Math::abs does not work so quare and divide gets us rid of the minus sign
    logDebug("SmartHeating","temperature determined = {}, actual temperature = {}, diff = {}, absolute diff = {}",temperature, actualTemperature, tempDiff, absoluteTempDiff)
    val boolean tempDiffBigEnough = (absoluteTempDiff > 2)
    logDebug("SmartHeating","actualWorkStateCold = {}, currentWorkStateCold = {}, temp diff big enough = {}", actualWorkStateCold, currentWorkStateCold, tempDiffBigEnough)
    if (actualWorkStateCold != currentWorkStateCold && tempDiffBigEnough) {
      logInfo("SmartHeating","OK, let's HEAT. actualWorkStateCold != currentWorkStateCold AND temp diff big enough -> setting temperature to {}", temperature)      
      Set_Bureau_IR_temp.sendCommand(temperature)
    } else {
      logDebug("SmartHeating","No heating. Heating conditions NOT met.")      
    }
end
