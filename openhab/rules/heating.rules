val Functions$Function0<String> getEmailText = [
  val String WAN_ADDRESS_FRITZ = "xdbu92gos1irkzbd.myfritz.net"
  wanAddress.postUpdate(WAN_ADDRESS_FRITZ)

  val String emailText='
    IP = http://'+wanAddress.state.toString+':8080/basicui/app?sitemap=garden_control\n
    Grafana = http://'+wanAddress.state.toString+':8030'/*GRAFANA_PORT*/+'/d/5KXuWvZRk/overview?tab=advanced&orgId=1&from=now-6h&to=now&refresh=1h\n
    Smart Home = http://'+wanAddress.state.toString+':8080/basicui/app?sitemap=smarthome\n'	
  //logDebug("getEmailText","EmailText  = {}",emailText)

  return emailText
]

// rule "floor heating pump night control"
// when 
//   Time cron "0 0/10 22-23,0-2 * 10-12,1-5 * " or
//   Time cron "0 0    0         * 6-8 *" // summer always OFF
//   then
//     val PumpOnOff = PumpeFussbodenheizung.state
//     val onOff = OFF
//     // the socket might be unavailable then it is OFF that's what we want
//     // if it is ON and it should be OFF we turn it OFF
//     // we just don't care and turn it OFF even if we do not know its state    
//     logDebug("floor heating pump night control", "night time, hour = {}, pump {}",now.hour,PumpOnOff)
//     PumpeFussbodenheizung.sendCommand(onOff)
//     logDebug("floor heating pump night control", "pump NOW is {}",onOff)
// end

// only the members of group "Alerting" will cause a mail to be sent when changed 
rule Bureau_IR_group_Alerting
when Member of Alerting changed
then
  	var actions = getActions("mail","mail:smtp:mysmtp")
  	actions.sendMail("uwe@janssen-muenchen.de","Alert rule: "+triggeringItem.name + " = "+triggeringItem.state, getEmailText.apply())
end
// Always log a change
rule Bureau_IR_group
when Member of Bureau_IR_group changed
then 
  logInfo("Bureau_IR_group", triggeringItem.name + " = "+triggeringItem.state)
end 

rule "Heating OFF"
// nightly heating stop
  when
    //Time cron "0 0/5 * * * ? " // near future test 
    Time cron "0 00 0-6 * * ? " or
    Time cron "0 00 21-23 * * ? "
  then
    Set_Bureau_IR_temp.sendCommand("18")
    DECT_301_radiator_mode.sendCommand("ECO")
end

rule "Heating Power" 
  when Member of HeatingDevices changed
  then
    var String varName = ""
    var Number varValue = 0
    // HeatingDevices.members.forEach[ item | 	
		// 	if (item.name.state == "OFF") {
		// 		do something with item.name
		// 	}
		// ]
    // create triggering object first
//    HeatingDevices.members.filter[ a | a.name == "Bureau_IR_work_state"] as SwitchItem
      varName = triggeringItem.name +"_Power"

      // TODO: use transformation ON,800 or 60 && OFF,0
    logInfo("Heating Power", triggeringItem.name + " = "+triggeringItem.state+" new varName = "+varName)
    val PowerItem = gHeatingPower.members.findFirst [ it | name == varName ] 
    logInfo("Heating Power", "PowerItem = "+ PowerItem)
      // TODO: use transformation ON,800 or 60 && OFF,0 
      // or use a hashMap for the different devices (bad since code had to be edited)
    if ( triggeringItem.state == ON || triggeringItem.state == "heating") {
      if (varName == "Bureau_IR_work_state_Power"){
        varValue = 800
      } else {
        varValue = 60
      }
    }
      else {
        varValue = 0
    }
    logInfo("Heating Power","setting "+ PowerItem + " TO "+varValue)
    PowerItem.postUpdate(varValue)
  end

rule "Smart heating"
//  control heating in bureau depending on power 
  when Member of gSmartPower changed
  then 
    val boolean lastEnoughPower = if (EnoughPowerLast.state == UNDEF || EnoughPowerLast.state == NULL || EnoughPowerLast.state == "false") false else true
    val Number HIGH_TEMP = 25
    val Number LOW_TEMP = 18
    val Number HEATING_POWER = 800
    val Number MIMINAL_LOAD_POWER = HEATING_POWER*1.5
    val Number solarPower =  Solar_power_calculated.state as Number * 1000 //  Watt
    val Number soc = SOC.state // battery level
    val Number MIN_SOC = 75
    val boolean enoughBattery =(soc > MIN_SOC)
    //val Number gridpower = (GridPower.state as Number)*1000
    val Number MIN_GRID_FEED = 100
    val Number gridPowerAverage_30minutes = GridPower.averageSince(now.minusMinutes(30))*1000
    val Number solarPowerMini = Solar600_P_AC.state as Number

    val boolean enoughPower = 
      enoughBattery ||
      (solarPower - HEATING_POWER > MIMINAL_LOAD_POWER) || 
      gridPowerAverage_10minutes > MIN_GRID_FEED /* or at least 100W grid feed in the last 10 minutes should be achieved */


    //val boolean socDecreasing =  (soc < socLast)
    val boolean shallHeat = /*!socDecreasing && */enoughPower
    val String POWER_STR = (if (enoughPower) "Enough Power. will HEAT " else "NOT ENOUGH POWER: Battery Level "+soc+"%; turn DOWN ")
    val boolean heatingPeriod = ( now.getHour > 9 && now.getHour < 23)
    var temperature = LOW_TEMP
    // PLAUSI CHECK:
    // if (grid power > 0 ) // einspeisung
    // && if solarPowerDach + SolarPowerMini > gridPower -> ERROR
    val Number powerSum = solarPower+solarPowerMini
    if (powerSum < gridPowerAverage_30minutes) {
      logError("Smart heating","SUM of Solar Power = {}  < gridPowerAverage = {} . DO NOTHING, just leave.",powerSum, gridPowerAverage_10minutes)
      return
    }



    //var Number socLast = if (SOCLastValue == UNDEF || SOCLastValue == NULL) = soc else SOCLastValue.state
    //logInfo("Smart heating DEBUG ","last enough power = {}, current enough power = {}",lastEnoughPower,enoughPower)
    logDebug("Smart heating",POWER_STR+". SOC state = {}%, Solar Power = {}, gridPowerAverage = {} ",SOC.state, solarPower, gridPowerAverage_10minutes)
    EnoughPowerLast.postUpdate(enoughPower+"")
    // conditions to do sth.
    // 
    // 1. there muste b a change of conditions versus last rule invocation 
    // 2. inside haeting period
    // 3. IR heater is not OFF
    val boolean doAnything = (enoughPower != lastEnoughPower) && heatingPeriod && Bureau_IR_on_off.state != OFF
    if (doAnything) {
      if (shallHeat) {
      // turn higher if ON
        temperature = HIGH_TEMP
        logInfo("Smart heating",POWER_STR+"HEATING,  turn IR temperature to {}", temperature)
      }
      Set_Bureau_IR_temp.sendCommand(temperature)
    } else {
      logDebug("Smart heating","No change -> do nothing, heatingPeriod = {}", heatingPeriod)
    }
end
