// Description: Rules for irrigation and water supply control 
// Author: Uwe Janssen
// Created: 14.05.2019
// -----------------------------------------------------------------------------
// History of changes
// Date       |  Change                                            | Author
// -----------------------------------------------------------------------------
// 14.05.2019 | Creation                                           | Janssen
// 26.05.2019 | comments changed                                   | Janssen
// 31.07.2019 | attempt to do some real programming                | Janssen
// -----------------------------------------------------------------------------
// import org.eclipse.xtext.xbase.lib.Functions
// import org.eclipse.xtext.xbase.lib.Procedures // not needed ???

import java.util.Map

val DEPRESSURE_TIME = 5
val String LEVEL_EMPTY = "1"
val String SCRIPT_DIR="/home/pi/scripts/"
val Number DONT_IRRIGATE_BEYOND = 3.0

var String level = LEVEL_EMPTY
var irrigating = false
var Number rainSum = 0 
var fillTimerActive = false

val Procedures$Procedure0 onDepressureTimer = [ 
        logInfo("Depressure", "onDepressureTimer invoked")
        water_on_off.sendCommand("0")
        Valve_Switch.postUpdate(OFF)
]

val Procedures$Procedure0 onFillTimer = [ 
        logInfo("Filling over", "onFillTimer invoked, fillTimerActive = {}", fillTimerActive)
        fillTimerActive = false
        water_on_off.sendCommand("0")
        Fill_Switch.postUpdate(OFF)
]

val irrOnOffProc = [ 
    String onOff, String SCRIPT_DIR |
                 executeCommandLine(SCRIPT_DIR+"irrOnOff.sh"+"@@"+onOff, 1000)
                 logInfo("irrOnOffProc", " invoked irrOnOff with parameter " + onOff)
]

val readLevel = [ 
  String SCRIPT_DIR
                    |
                  logInfo("Read level", "readLevel invoked with par = {}",SCRIPT_DIR)
                  var level = executeCommandLine(SCRIPT_DIR+"Level.sh", 6000)
                  logInfo("Read level", "readLevel() result = {}",level)
                  level.toString
]

rule "Trigger irrigation pump"
  when Item Irr_Switch received command
  then

    var String cmd = null
    
    switch (receivedCommand){
        case ON: {
          cmd = "1"
          irrigating = true
          logInfo("Trigger irrigation pump","received command = "+receivedCommand+", cmd set to = "+cmd)
          }
        case OFF: {
          cmd = "0"
          irrigating = false
          logInfo("Trigger irrigation pump","received command = "+receivedCommand+", cmd set to = "+cmd)
        }
        default: 
          logInfo("Trigger irrigation pump","received command neither ON nor OFF")
    }

    logInfo("Trigger irrigation pump","irrigating_ set to " + irrigating)

    if(cmd !== null) 
    {
      irr_on_off.sendCommand(cmd)
    }
end

rule "Trigger water valve"
  when Item Valve_Switch received command
  then
    var String cmd = null
    switch(receivedCommand){
        case ON: cmd = "1"
        case OFF: cmd = "0"
        default: logError("water valve", "Do not know how to handle " + receivedCommand.toString)
    }

    if(cmd !== null) water_on_off.sendCommand(cmd)
end

rule "High level fill barrel for next irrigation"
// fill up barrel except when raining or rain has been forecast
  when Item Fill_Switch received command
  then
    logInfo("FILL barrel rule", "received command = " + receivedCommand.toString)
    var String level = LEVEL_EMPTY
    switch(receivedCommand){
        case ON: {
          if (LocalCurrentRainVolume.state > 0 || ForecastRainVolumesGroup.state >  DONT_IRRIGATE_BEYOND) {      
            logInfo("Irrigation ON rule","NO refill, either raining: ("+LocalCurrentRainVolume.state+", or future rain = "+ForecastRainVolumesGroup.state)
          } else {
            logInfo("FILL barrel rule", "starting fill barrel cycle")
            fillTimerActive = true
            createTimer (now.plusSeconds(120), onFillTimer) // at most 200 filling time whatever level indicator tells
            while (level == LEVEL_EMPTY && fillTimerActive) {
              water_on_off.sendCommand("1")
              level = readLevel.apply(SCRIPT_DIR)
              logInfo("FILL barrel rule","level = " + level)
              if (level == "0" ) // 0=full 
              {
                logInfo("FILL barrel rule","Found barrel full")
                fillTimerActive = false
                water_on_off.sendCommand("0")
              } // full
              Thread::sleep(10000)
            } // end while
            logInfo("FILL barrel rule","END while loop since level is no longer empty or filltimer expired")
          } // end if rain condition
        } // end case ON
        case OFF: water_on_off.sendCommand("0")
        default: logError("FILL barrel", "I Do not know how to handle " + receivedCommand.toString)
    }
end

rule "Depressure"
// Takes away pressure from supply water hose
// This is done by turning on tap water for a few seconds, then turn off again 
// Even works when tap faucet is closed
// so all along the hose there will be less pressure

  when 
    Time cron "0 3/20 9-17 * * ?"
    //Time cron "0 0/2 9-20 * * ?"
  then
    logInfo("Depressure rule", "Cron event is due, start depressuring and timer") 
    var String isRaining = executeCommandLine("/home/pi/scripts/isRaining.sh", 1000)
    logInfo("Rule Depressure", "isRaining = " + isRaining)
    Valve_Switch.sendCommand(ON)
    water_on_off.sendCommand("1")
    createTimer (now.plusSeconds(DEPRESSURE_TIME), onDepressureTimer)
end

// This rule serves as a steady bgackground task running all five minutes
rule "daemon"
  when 
    //  Time cron "0 0/1 * * * ?" //near future test
    Time cron "0 0/5 * * * ?" // every 5 minutes check
  then

  logInfo("ForecastRainVolumesGroup ( SUM )  = ",ForecastRainVolumesGroup.state.toString)
    
  // if someone ( e.g. low level script ) turned OFF irrigation on inadvertedly
  // -> turn ON again 
  if (irrigating) {
      logInfo("rule Supervise irrigation state", "found irrigation is active, so turn it ON")
      irrOnOffProc.apply("1", SCRIPT_DIR)
  }
  // save water: 
  // never let water running for more than five minutes
  Valve_Switch.sendCommand(OFF)
  water_on_off.sendCommand("0")
end


rule "Irrigation ON"
// time based beginning of irrigation
  when
//    Time cron "0 0/1 * * * ? " or // near future test 
    Time cron "0 00 05 * * ? " or
    Time cron "0 00 06 * * ? " or 
    Time cron "0 00 18 * * ? " or
    Time cron "0 00 19 * * ? "  
  then
    
    // TODO BEGIN first make sure barrel has enough water 
    // fill_barrel.sendCommand("1")
    // TODO END
    var Map <String, Map <Boolean,String>> irrigationMap = newHashMap()
    val String TRUE_STRING  = "Bewaesserung: EIN \nWasserstand: "+level_out.state.toString
    val String FALSE_STRING = "KEINE Bewaesserung, es regnet oder f체r die n채chsten 24 h ist Regen mit " + ForecastRainVolumesGroup.state + " angesagt "
    
    irrigationMap.put("IRROFF", 
      newHashMap(
       false -> FALSE_STRING
       ) as Map<Boolean,String>
       )

    irrigationMap.put("IRRON" , 
      newHashMap(
         true  -> TRUE_STRING
         ) as Map<Boolean,String>
      )
    // Irrigate except forecast tells otherwise


    logInfo("Irrigation ON rule","isRaining = " + LocalCurrentRainVolume.state +", rainForeCast 24hrs  = "+ForecastRainVolumesGroup.state)
    if (LocalCurrentRainVolume.state > 0 || ForecastRainVolumesGroup.state >  DONT_IRRIGATE_BEYOND) {
      irrigating = false
      logInfo("Irrigation ON rule","NO irrigating , either raining: ("+LocalCurrentRainVolume.state+", or future rain = "+ForecastRainVolumesGroup.state)
      sendMail("uwe@janssen-muenchen.de","Keine Bewaesserung", "KEINE Bewaesserung, es regnet oder f체r die n채chsten 24 h ist Regen mit " + ForecastRainVolumesGroup.state + " angesagt ")
    } else {
      Irr_Switch.sendCommand(ON)
      irr_on_off.sendCommand("1")
      irrigating = true
      logInfo("Irrigation ON rule","irrigating set to " + irrigating)
      sendMail("uwe@janssen-muenchen.de","Bewaesserung", "Bewaesserung: EIN \nWasserstand: "+level_out.state.toString)
    }
    
end

rule "Irrigation OFF"
// time based ceasing of irrigation
  when
    //Time cron "0 1/2 * * * ? " or // near future test 
    Time cron "0 00 07 * * ? " or
    Time cron "0 00 20 * * ? " 
  then   
    logInfo("Irrigation OFF rule", "Cron event is due, stop irrigation")
    Irr_Switch.sendCommand(OFF)
    irr_on_off.sendCommand("0")
    irrigating = false
    sendMail("uwe@janssen-muenchen.de","Bewaesserung", "Bewaesserung: AUS \nWasserstand: "+level_out.state.toString)
end
