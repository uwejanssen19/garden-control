// Description: Rules for irrigation and water supply control 
// Author: Uwe Janssen
// Created: 14.05.2019
// -----------------------------------------------------------------------------
// History of changes
// Date       |  Change                                            | Author
// -----------------------------------------------------------------------------
// 14.05.2019 | Creation                                           | Janssen
// 26.05.2019 | comments changed                                   | Janssen
// 31.07.2019 | attempt to do some real programming                | Janssen
// 12.08.2019 | added rule for handling test mode                  | Janssen
// 20.08.2019 | added comments                                     | Janssen
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
//  imports
// -----------------------------------------------------------------------------

import java.util.Map

// -----------------------------------------------------------------------------
// constants
// -----------------------------------------------------------------------------

val DEPRESSURE_TIME = 5
val String LEVEL_EMPTY = "1"
val String SCRIPT_DIR="/home/pi/scripts/"
val MAX_FILL_BARREL_TIME = 240

// -----------------------------------------------------------------------------
//  file global variables
// -----------------------------------------------------------------------------

var String level = LEVEL_EMPTY
var irrigating = false
var Number rainSum = 0 

// -----------------------------------------------------------------------------
//  Functions and procedures section
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
//  Function shallIrrigate
// -----------------------------------------------------------------------------

val Functions$Function0<Boolean> shallIrrigate = [ 
  // if switch is = ON OR either not raining or coming rain less than defined amount
  logInfo("shallIrrigate::","LocalCurrentRainVolume = {}", LocalCurrentRainVolume.state)
  logInfo("shallIrrigate::","ForecastRainVolumesGroup = {}", ForecastRainVolumesGroup.state)
  // logInfo("shallIrrigate::","IgnoreWeatherSwitch = {}", IgnoreWeatherSwitch.state)
  
  val currentRainVal = (LocalCurrentRainVolume?.state as DecimalType).floatValue
  // logInfo("shallIrrigate::","currentRainVal = {}", currentRainVal)
  var float comingRainVal  = (ForecastRainVolumesGroup?.state as DecimalType).floatValue
  // logInfo("shallIrrigate::","comingRainVal = {}", comingRainVal)

  val Boolean switchStateSetToIgnore  = (IgnoreWeatherSwitch?.state == ON)
    
  val Number RAIN_TRESHOLD = 3.0
  val Boolean willNotRain = (comingRainVal < RAIN_TRESHOLD)  
  val Boolean isNotRaining = (currentRainVal == 0.0)    
  val Boolean weatherSuitableForIrrigating  =  (isNotRaining && willNotRain)
    
  // logInfo("shallIrrigate::","switchStateSetToIgnore = {} ",switchStateSetToIgnore)
  // logInfo("shallIrrigate::","comingRainVal = {} ",comingRainVal)
  // logInfo("shallIrrigate::","willNotRain = {} ",willNotRain)
  // logInfo("shallIrrigate::","isNotRaining = {} ",isNotRaining)
  logInfo("shallIrrigate::","weatherSuitableForIrrigating = {} ",weatherSuitableForIrrigating)
    
  if (switchStateSetToIgnore || (weatherSuitableForIrrigating)) {
    logInfo("shallIrrigate::","return true")
    return true
  }
  else {
    logInfo("shallIrrigate::","return false")
    return false 
  }
  
   
]
// -----------------------------------------------------------------------------
//  Timer onFillTimer
// -----------------------------------------------------------------------------

val Procedures$Procedure0 onFillTimer = [ 
        FillTimerActive.postUpdate(OFF)
        logInfo("Filling is over", "onFillTimer invoked")
        water_on_off.sendCommand("0")
        Fill_Switch.postUpdate(OFF)
]

// -----------------------------------------------------------------------------
//  Timer onDepressureTimer
// -----------------------------------------------------------------------------

val Procedures$Procedure0 onDepressureTimer = [ 
        logInfo("Depressure Timer", "onDepressureTimer invoked")
        water_on_off.sendCommand("0")
        GardencontrolPowerSupply.sendCommand(OFF) // deactivate PowerSupply for pump and valve
        Valve_Switch.postUpdate(OFF)
]

// -----------------------------------------------------------------------------
//  Procedure irrOnOffProc, turn on or off irrigation
// -----------------------------------------------------------------------------

val irrOnOffProc = [ 
    String onOff, String SCRIPT_DIR |
                 executeCommandLine(SCRIPT_DIR+"irrOnOff.sh"+"@@"+onOff, 1000)
                 logInfo("irrOnOffProc", " invoked irrOnOff with parameter " + onOff)
]

// -----------------------------------------------------------------------------
//  lambda readLevel>
// -----------------------------------------------------------------------------

val readLevel = [ 
  String SCRIPT_DIR
                    |
                  //logInfo("Read level", "readLevel invoked with par = {}",SCRIPT_DIR)
                  GardencontrolPowerSupply.sendCommand(ON) // activate PowerSupply for pump and valve
                  Thread::sleep(2000)
                  var level = executeCommandLine(SCRIPT_DIR+"Level.sh", 6000)
                  logInfo("Read level", "readLevel() result = {}",level)
                  level.toString
]

// -----------------------------------------------------------------------------
//  Manual irrigation
// -----------------------------------------------------------------------------

rule "Manual Trigger irrigation pump"
  when Item Irr_Switch received command
  then

    var String cmd = "0"
    irrigating=false
    // var String text = "ignored manual irrigation command = "+receivedCommand+" beacause of the weather"
       
    switch (receivedCommand){
        case ON: {
          // always irrigate manually, do not caare of the weather
          //if (shallIrrigate.apply() == true) {
            cmd = "1"
            irrigating = true
          // } else { // else leave cmd and irrigating state as defined above
          //   logInfo("Manual Trigger irrigation pump",text)
             StatusText.postUpdate("Irrigation started")
          //   Irr_Switch.sendCommand(OFF)
          // }
        }
        case OFF: {
          logInfo("Manual Trigger irrigation pump","turned irrigation OFF")
        }
        default: 
          logInfo("Trigger irrigation pump","received command neither ON nor OFF")
    }

    logInfo("Manual Trigger irrigation pump","received command = "+receivedCommand+", cmd set to = "+cmd)
    logInfo("Manual Trigger irrigation pump","irrigating state set to " + irrigating)

    if(cmd !== null) 
    {
      irr_on_off.sendCommand(cmd)
    }
end

// -----------------------------------------------------------------------------
//  Manual fill barrel trigger
// -----------------------------------------------------------------------------

rule "Trigger water valve"
  when Item Valve_Switch received command
  then
    var String cmd = null
    switch(receivedCommand){
        case ON: cmd = "1"
        case OFF: cmd = "0"
        default: logError("water valve", "Do not know how to handle " + receivedCommand.toString)
    }

    if(cmd !== null) water_on_off.sendCommand(cmd)
end

// -----------------------------------------------------------------------------
//  Fill barrel for next irrigation
// -----------------------------------------------------------------------------

rule "Fill barrel for next irrigation"
// fill up barrel except when raining or rain has been forecast
  when Item Fill_Switch received command
  then
    logInfo("FILL barrel rule", "received command = " + receivedCommand.toString)
    var String level = LEVEL_EMPTY
    switch(receivedCommand){
        case ON: {
          if (!(shallIrrigate.apply())) {
          //if (LocalCurrentRainVolume.state > 0 || ForecastRainVolumesGroup.state >  DONT_IRRIGATE_BEYOND) {      
             logInfo("Fill barrel rule","NO refill, either raining: ("+LocalCurrentRainVolume.state+", or future rain = "+ForecastRainVolumesGroup.state)
             StatusText.postUpdate("NO refill due to weather, future rain = "+ForecastRainVolumesGroup.state)
           } else {
             logInfo("FILL barrel rule", "starting fill barrel cycle")
          
            FillTimerActive.postUpdate( ON )
            var maxTimer = createTimer (now.plusSeconds(MAX_FILL_BARREL_TIME), onFillTimer) // at most 200 filling time whatever level indicator tells
            while (level == LEVEL_EMPTY && FillTimerActive.state == ON) {
              logInfo("FILL barrel rule","INSIDE while loop since level is empty or filltimer active")
              GardencontrolPowerSupply.sendCommand(ON) // activate PowerSupply for pump and valve
              Thread::sleep(2000)
              water_on_off.sendCommand("1")
              level = readLevel.apply(SCRIPT_DIR)
              logInfo("FILL barrel rule","level = " + level)
              if (level == "0" ) // 0=full 
              {
                logInfo("FILL barrel rule","Found barrel full")
                FillTimerActive.postUpdate(OFF)
                maxTimer?.cancel()
                Fill_Switch.postUpdate(OFF)
                water_on_off.sendCommand("0")
              } // full
              //logInfo("FILL barrel rule","START waiting 10 s")
              Thread::sleep(10000)
              //logInfo("FILL barrel rule","STOP waiting 10 s")
            } // end while
            logInfo("FILL barrel rule","END while loop since level is no longer empty or filltimer expired")
            maxTimer?.cancel()
          } // end if rain condition
          Fill_Switch.postUpdate(OFF)
        } // end case ON
        case OFF: water_on_off.sendCommand("0")
        default: logError("FILL barrel", "I Do not know how to handle " + receivedCommand.toString)
    }
end

// -----------------------------------------------------------------------------
//  Depressure task. Needed to take away pressure from the hose when exposed to the sun
// -----------------------------------------------------------------------------

rule "Depressure"
// Takes away pressure from supply water hose
// This is done by turning on tap water for a few seconds, then turn off again 
// Even works when faucet is closed
// so all along the hose there will be less pressure

  when 
    //Time cron "0 0/2 9-23 * * ?" // for TEST
    Time cron "0 3/20 9-17 * * ?"
  then
    val cloudiness = LocalCurrentCloudiness.state as Number
    logInfo("Depressure", "LocalCurrentCloudiness = {}", cloudiness) 
    StatusText.sendCommand("Depr since cloudiness = "+cloudiness)
    if (cloudiness >= 0.5) {
      logInfo("Depressure", "cloudiness more than {}% -> so relieving hose is not needed",cloudiness)
    } else {
      logInfo("Depressure", "cloudiness = {}, i.e. < 50% -> start depressurizing", cloudiness) 
      GardencontrolPowerSupply.sendCommand(ON) // activate PowerSupply for pump and valve
      Thread::sleep(2000)
      Valve_Switch.postUpdate(ON)
      water_on_off.sendCommand("1")
      createTimer (now.plusSeconds(DEPRESSURE_TIME), onDepressureTimer)
    }
end

// -----------------------------------------------------------------------------
//  Background daemon for various tasks
// -----------------------------------------------------------------------------

// This rule serves as a steady bgackground task running all five minutes
rule "daemon"
  when 
    //  Time cron "0 0/1 * * * ?" //near future test
    Time cron "0 0/5 * * * ?" // every 5 minutes check
  then

  logInfo("Daemon:","ForecastRainVolumesGroup ( SUM )  = {} ",ForecastRainVolumesGroup.state.toString)
    
  // if someone ( e.g. low level script ) turned OFF irrigation on inadvertedly
  // -> turn ON again 
  if (irrigating) {
      logInfo("Daemon:", "found irrigation is active, so turn it ON")
      irrOnOffProc?.apply("1", SCRIPT_DIR)
  }
  // save water: 
  // never let water running for more than daemon run time interval (see above)
  Valve_Switch?.sendCommand(OFF)
  water_on_off?.sendCommand("0")
  // tunr on power since we need power for the background 20 minutes Level measuring
  GardencontrolPowerSupply.sendCommand(ON) // activate PowerSupply for pump and valve
end


// -----------------------------------------------------------------------------
//  Irrigation ON
// -----------------------------------------------------------------------------

rule "Irrigation ON"
// time based beginning of irrigation
  when
    //Time cron "0 0/2 * * * ? " or // near future test 
    Time cron "0 00 05 * * ? " or
    Time cron "0 00 06 * * ? " or 
    Time cron "0 00 18 * * ? " or
    Time cron "0 00 19 * * ? "  
  then
    
    // TODO BEGIN first make sure barrel has enough water 
    // fill_barrel.sendCommand("1")
    // TODO END
    var Map <String, Map <Boolean,String>> irrigationMap = newHashMap()
    val String TRUE_MAIL_TEXT  = "Irrigation via CRON: Bewaesserung: EIN \nWasserstand: "+Level_out.state.toString
    val String FALSE_MAIL_TEXT = "Irrigation via CRON: KEINE Bewaesserung, es regnet oder für die nächsten 24 h ist Regen mit " + ForecastRainVolumesGroup.state + " angesagt "
    
    irrigationMap.put("IRROFF", 
      newHashMap(
       false -> FALSE_MAIL_TEXT
       ) as Map<Boolean,String>
       )

    irrigationMap.put("IRRON" , 
      newHashMap(
         true  -> TRUE_MAIL_TEXT
         ) as Map<Boolean,String>
      )

    // Irrigate except forecast tells otherwise
    logInfo("Irrigation via CRON","isRaining = " + LocalCurrentRainVolume.state +", rainForeCast 24hrs  = "+ForecastRainVolumesGroup.state)
    if (shallIrrigate.apply() == true ) {
      GardencontrolPowerSupply.sendCommand(ON) // activate PowerSupply for pump and valve
      // trigger fill barrel rule,
      logInfo("Irrigation via CRON", "turn on fill_switch")
      // tripping the fillswitch serves as a subroutine call here
      Fill_Switch.sendCommand(ON)
      Irr_Switch.sendCommand(ON)
      irr_on_off.sendCommand("1")
      irrigating = true
      logInfo("Irrigation via CRON","irrigating set to " + irrigating)
      sendMail("uwe@janssen-muenchen.de","Bewaesserung", "Bewaesserung: EIN \nWasserstand: "+Level_out.state.toString)
    } else {
      Irr_Switch.sendCommand(OFF)
      irr_on_off.sendCommand("0")
      irrigating = false
      logInfo("Irrigation ON rule","NO irrigating , either raining: ("+LocalCurrentRainVolume.state+", or future rain = "+ForecastRainVolumesGroup.state)
      sendMail("uwe@janssen-muenchen.de","Keine Bewaesserung", "KEINE Bewaesserung, es regnet oder für die nächsten 24 h ist Regen mit " + ForecastRainVolumesGroup.state + " angesagt ")
    }
    
end

// -----------------------------------------------------------------------------
//  Irrigation OFF
// -----------------------------------------------------------------------------

rule "Irrigation OFF"
// time based ceasing of irrigation
  when
    //Time cron "0 1/2 * * * ? " or // near future test 
    Time cron "0 00 07 * * ? " or
    Time cron "0 00 20 * * ? " 
  then   
    logInfo("Irrigation OFF rule", "Cron event is due, stop irrigation")
    Irr_Switch.sendCommand(OFF)
    GardencontrolPowerSupply.sendCommand(OFF) // deactivate PowerSupply for pump and valve
    irr_on_off.sendCommand("0")
    irrigating = false
    sendMail("uwe@janssen-muenchen.de","Bewaesserung", "Bewaesserung: AUS \nWasserstand: "+Level_out.state.toString)
end

// -----------------------------------------------------------------------------
//  Trigger Update Water Level
// -----------------------------------------------------------------------------

rule "Update Manual Water Level Display"
when 
  Item UpdateLevelSwitch received command
then 
  logInfo("Rule: Manual Water Level Update", "UpdateLevelSwitch has been pushed: {} ", receivedCommand)
  // just for test since we do not want to wait for some timer to occur
  if (receivedCommand == ON) {
    val willIrrigate = shallIrrigate.apply()
    logInfo("Rule: Manual Water Level Update", "willIrrigate = {} ",willIrrigate)
    GardencontrolPowerSupply.sendCommand(ON) // activate PowerSupply for pump and valve
    Thread::sleep(2000)
    level = readLevel.apply(SCRIPT_DIR)
    //Display_level_out?.postUpdate(level) 
    Level_out.postUpdate(level)
    StatusText.sendCommand("Update Level - waiting for level value ...")
    StatusText.sendCommand("Update Level, level = "+level)
    // val cloudiness = LocalCurrentCloudiness.state as Number
    // logInfo("Depressure rule", "LocalCurrentCloudiness = {}", cloudiness) 
    // StatusText.sendCommand("Update LocalCurrentCloudiness = "+cloudiness)
    // if (cloudiness < 0.5) {
    //   logInfo("", "cloudiness < 50%") 

    // } else {
    //   logInfo("", "cloudiness >= 50%") 
    // }
    InitSwitch?.postUpdate(OFF)
    GardencontrolPowerSupply.sendCommand(OFF) // deactivate PowerSupply for pump and valve
  }
  
end

// -----------------------------------------------------------------------------
//  rule  "Test Mode Switch handling"
// -----------------------------------------------------------------------------

rule  "Test Mode Switch handling"
  when Item TestModeSwitch changed to ON 
  then 
    InitSwitch.postUpdate(OFF)
  end 

rule "SysStart"
when 
  System started                 or
  Item InitSwitch changed to ON
then 
  InitSwitch.sendCommand(OFF)
  Irr_Switch.sendCommand(OFF)
  Valve_Switch.sendCommand(OFF)
  Fill_Switch.sendCommand(OFF)
  FillTimerActive.sendCommand(OFF) 

  Display_level_out.sendCommand("0")
  UpdateLevelSwitch.sendCommand(OFF)
  StatusText.sendCommand("System started")

  Level_out.sendCommand("0")
  // make all fields visible
  TestModeSwitch.sendCommand(ON)
  GardencontrolPowerSupply.sendCommand(ON)
end 

// -----------------------------------------------------------------------------
// rule "SysStop" 
// -----------------------------------------------------------------------------

rule "SysStop"
when System shuts down

then
    InitSwitch.sendCommand(ON)
    logInfo("SysStop:", "system shutting down")

end

// -----------------------------------------------------------------------------
//  rule "Level by script"
// -----------------------------------------------------------------------------

rule "Level by script"
when 
  Item Level_from_periodic_script received command
then 
  logInfo("Level by script", "receivedCommand = {} ", receivedCommand)
  var cmd = "0"
    switch(receivedCommand){
        case ON: cmd = "1"
        case OFF: cmd = "0"
        default: logError("rule Level by script", "Do not know how to handle " + receivedCommand.toString)
  }
  Display_level_out.postUpdate(cmd)
end
